'''Description: Script for performing standard Over-Representation Analysis (ORA) with fdr correction.'''import pandas as pd  # For data manipulation and analysisimport scipy.stats as stats  # For statistical functionsimport os  # For file and directory operationsimport argparse  # For command-line argument parsingimport tqdm  # For progress bar displayimport sysfrom typing import List, Tuple, Optional  # For type annotations# Add the project root to sys.pathscript_dir = os.path.dirname(os.path.abspath(__file__))project_root = os.path.abspath(os.path.join(script_dir, '..'))sys.path.insert(0, project_root)from preprocessing.qvalue import qvaluesdef load_pathway_ids(file_path):    '''Load and categorize pathway IDs into 'cancer' and 'infection'.'''    ids = {'cancer': [], 'infection': []}    with open(file_path, 'r') as file:        current_category = None        for line in file:            line = line.strip()            if line.startswith('#'):                if 'cancer' in line:                    current_category = 'cancer'                elif 'infection' in line:                    current_category = 'infection'            elif line:                ids[current_category].append(line)    return idsdef load_query(query_file: str, query_membership_type: str) -> pd.DataFrame:    '''Load and clean query data from a file.'''    if not os.path.isfile(query_file):        raise FileNotFoundError(f"Query file '{query_file}' does not exist.")        query_df = pd.read_csv(query_file, sep='\t')        if 'Ensembl_ID' not in query_df.columns or query_membership_type not in query_df.columns:        raise ValueError(f"Query file must contain 'Ensembl_ID' and '{query_membership_type}' columns.")        query_df = query_df.dropna().rename(columns={query_membership_type: 'Query_Membership'})    return query_dfdef load_pathways(pathway_file: str, pathway_membership_type: str) -> pd.DataFrame:    '''Load and aggregate pathway data from a file.'''    if not os.path.isfile(pathway_file):        raise FileNotFoundError(f"Pathway file '{pathway_file}' does not exist.")        pathway_df = pd.read_csv(        pathway_file,        sep='\t',        usecols=['Pathway_Name', 'Description', 'Ensembl_ID', pathway_membership_type],        dtype={'Ensembl_ID': str, pathway_membership_type: float}    )        if 'Pathway_Name' not in pathway_df.columns or 'Description' not in pathway_df.columns or pathway_membership_type not in pathway_df.columns:        raise ValueError(f"Pathway file must contain 'Pathway_Name', 'Description', and '{pathway_membership_type}' columns.")        exclude_pathways = {'hsa01100', 'hsa01200', 'hsa04740', 'hsa05168'}    pathway_df = pathway_df[~pathway_df['Pathway_Name'].isin(exclude_pathways)]        pathway_df = pathway_df.dropna().rename(columns={pathway_membership_type: 'Pathway_Membership'})    pathway_df = pathway_df.groupby('Pathway_Name').agg({        'Description': 'first',        'Ensembl_ID': list,        'Pathway_Membership': list    }).reset_index()        return pathway_dfdef hypergeometric_test(query_genes: List[str], pathway_genes: List[str], universe_size: int) -> Tuple[int, float]:    '''Perform a hypergeometric test to find p-value for gene overlap.'''    if universe_size <= 0:        raise ValueError("Universe size must be greater than zero.")    if not query_genes or not pathway_genes:        return 0, 1.0  # Return zero overlap and p-value of 1 if no genes        overlap_genes = set(query_genes).intersection(pathway_genes)    overlap_size = len(overlap_genes)        query_size = len(query_genes)    pathway_size = len(pathway_genes)    p_value = stats.hypergeom.sf(overlap_size - 1, universe_size, pathway_size, query_size)        return overlap_size, p_valuedef standard_ora_compute_stats(pathway: pd.Series, query_df: pd.DataFrame, universe_size: int) -> Tuple[int, float]:    '''Compute overlap size and p-value for a given pathway.'''    query_genes = query_df['Ensembl_ID'].tolist()    query_genes_filtered = query_df[query_df['Query_Membership'] == 1]['Ensembl_ID'].tolist()        pathway_genes = pathway['Ensembl_ID']    pathway_memberships = pathway['Pathway_Membership']        pathway_genes_filtered = [        gene for gene, membership in zip(pathway_genes, pathway_memberships)        if membership == 1 and gene in query_genes    ]        overlap_size, p_value = hypergeometric_test(query_genes_filtered, pathway_genes_filtered, universe_size)        return overlap_size, p_valuedef standard_ora(    query_file: str,    pathway_file: str,    query_membership_type: str = 'Crisp_Membership',    pathway_membership_type: str = 'Crisp_Membership',    output_path: Optional[str] = None,    dataset_name: str = '',    pathway_ids: Optional[List[str]] = None) -> pd.DataFrame:    '''Perform standard Over-Representation Analysis (ORA).'''    query_df = load_query(query_file, query_membership_type)    pathway_df = load_pathways(pathway_file, pathway_membership_type)        if pathway_ids is not None:        pathway_df = pathway_df[pathway_df['Pathway_Name'].isin(pathway_ids)]        universe_size = len(query_df)    num_pathways = len(pathway_df)        results = []    for _, pathway in tqdm.tqdm(pathway_df.iterrows(), total=num_pathways, desc="Processing Pathways"):        overlap_size, p_value = standard_ora_compute_stats(pathway, query_df, universe_size)        results.append({            'Pathway_Name': pathway['Pathway_Name'],            'Description': pathway['Description'],            'Observed_Intersection': overlap_size,            'p_value': p_value        })        results_df = pd.DataFrame(results).sort_values('p_value').reset_index(drop=True)    results_df['Rank'] = results_df['p_value'].rank(method='min').astype(int)    results_df['p_value'] = results_df['p_value'].astype(float)        results_df = qvalues(results_df, p_col="p_value", q_col="q_value")        results_df['p_value'] = results_df['p_value'].apply(lambda x: f"{x:.4e}")    results_df['q_value'] = results_df['q_value'].apply(lambda x: f"{x:.4e}")        if output_path:        results_folder = os.path.join(output_path, dataset_name)        os.makedirs(results_folder, exist_ok=True)        results_file_name = f"{dataset_name}_{query_membership_type}_{pathway_membership_type}_results.csv"        results_df.to_csv(os.path.join(results_folder, results_file_name), index=False)        return results_dfdef standard_ora_main():    """Parse command-line arguments and execute the standard_ora function."""    parser = argparse.ArgumentParser(description="Run standard ORA analysis.")    parser.add_argument('-q', '--query_file', required=True, help="Path to the query file.")    parser.add_argument('-p', '--pathway_file', required=True, help="Path to the pathway file.")    parser.add_argument('-q_name', '--query_membership_type', default='Crisp_Membership', help="Query membership type.")    parser.add_argument('-p_name', '--pathway_membership_type', default='Crisp_Membership', help="Pathway membership type.")    parser.add_argument('-o', '--output_path', default=None, help="Output directory path.")    parser.add_argument('-d', '--dataset_name', default='', help="Dataset name for output files.")    parser.add_argument('--pathway_ids', nargs='+', help="List of specific pathway IDs to include.")        args = parser.parse_args()        # Execute the standard ORA function with the parsed arguments    standard_ora(        query_file=args.query_file,        pathway_file=args.pathway_file,        query_membership_type=args.query_membership_type,        pathway_membership_type=args.pathway_membership_type,        output_path=args.output_path,        dataset_name=args.dataset_name,        pathway_ids=args.pathway_ids    )if __name__ == "__main__":    standard_ora_main()